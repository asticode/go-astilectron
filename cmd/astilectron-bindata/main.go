package main

import (
	"flag"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"runtime"

	"github.com/asticode/go-astilectron"
	"github.com/veecue/go-astilectron-bindata"
)

var currentOsOnly = flag.Bool("c", false, "Only download electron for the current os")

/*func Disembed(src string) ([]byte, error) {
	if src == "astilectron.zip" {
		return nil, nil
	} else if src == "electron.zip" {
		return nil, nil
	} else {
		return nil, errors.New("Wrong argument!")
	}
}*/

type W struct {
	io.Writer
}

func (w *W) Write(p []byte) (n int, err error) {
	for _, b := range p {
		_, err = fmt.Fprintf(w.Writer, "\\x%02x", b)
	}
	n = len(p)
	return
}

func handleOS(o, a string) {
	if o == "darwin" && a == "386" {
		return
	}
	file, err := os.Create(fmt.Sprintf("astilectron_vendor_%s_%s.go", o, a))
	defer file.Close()
	if err != nil {
		log.Fatal(err)
	}
	file.WriteString(`// Generated by go-astilectron-bindata

// +build ` + o + `
// +build ` + a + `

package main
import "errors"
`)
	file.WriteString(`func Disembed(src string) ([]byte, error) {
if src == "` + astilectron_bindata.SrcFileNameAstilectron + `" {
return []byte("`)
	resp, err := http.Get(astilectron.AstilectronDownloadSrc())
	if err != nil {
		log.Fatal(err)
	}
	_, err = io.Copy(&W{Writer: file}, resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	file.WriteString(`"), nil
} else if src == "` + astilectron_bindata.SrcFileNameElectron + `" {
return []byte("`)
	resp, err = http.Get(astilectron.ElectronDownloadSrc(o, a))
	if err != nil {
		log.Fatal(err)
	}
	_, err = io.Copy(&W{Writer: file}, resp.Body)
	if err != nil {
		log.Fatal(err)
	}
	file.WriteString(`"), nil
} else {
return nil, errors.New("Wrong argument!")
}
}`)
}

func main() {
	flag.Parse()
	if *currentOsOnly {
		handleOS(runtime.GOOS, runtime.GOARCH)
	} else {
		for _, o := range astilectron.ValidOSes() {
			for _, a := range []string{"amd64", "386"} {
				handleOS(o, a)
			}
		}
	}
}
